<html>
<head>
	<style type="text/css">
	body {
		font-family: helvetica, arial, sans-serif;
	}
	#msg {
		font-family: monospace;
		font-size: 0.7em;
		position: fixed;
		top: 10px;
		right: 30px;
		width: 600px;
		height: 250px;
		background-color: white;
		border: 1px dotted #999;
		opacity: 0.9;
	}
	#paper {
		margin-top: 150px;
	}
	#control {
		position: fixed;	
		top: 10px;	
		left: 20px;
	}
	.close-btn {
  display: block;
  position: absolute;
  top: -8px;
  right: -8px;
  height: 0;
  width: 18px;
  padding: 18px 0 0 0;
  overflow: hidden;
  background: #000000 none;
  border: 2.04545454545455px solid #ffffff;
  -moz-border-radius: 18px;
  -webkit-border-radius: 18px;
  border-radius: 18px;
  box-shadow: 0 0 6px #000000, 1.63636363636364px 1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3), -1.63636363636364px 1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3), 1.63636363636364px -1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3), -1.63636363636364px -1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3);
  -ms-box-shadow: 0 0 6px #000000, 1.63636363636364px 1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3), -1.63636363636364px 1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3), 1.63636363636364px -1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3), -1.63636363636364px -1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3);
  -moz-box-shadow: 0 0 6px #000000, 1.63636363636364px 1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3), -1.63636363636364px 1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3), 1.63636363636364px -1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3), -1.63636363636364px -1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3);
  -webkit-box-shadow: 0 0 6px #000000, 1.63636363636364px 1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3), -1.63636363636364px 1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3), 1.63636363636364px -1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3), -1.63636363636364px -1.63636363636364px 1.63636363636364px rgba(0, 0, 0, 0.3);
  color: #ffffff;
  cursor: pointer;
  -moz-user-select: none;
  -webkit-user-select: none;
  user-select: none;
}
.close-btn:before {
  content: "\D7";
  display: block;
  text-align: center;
  width: 18px;
  position: absolute;
  top: -1.8px;
  left: 0;
  font-size: 18px;
  line-height: 18px;
  font-family: "Helvetica Neue", Consolas, Verdana, Tahoma, Calibri, Helvetica, Menlo, "Droid Sans", sans-serif;
  top: -2px;
  left: 1px;
}
	</style>
	<link rel="stylesheet" type="text/css" href="/jquery-ui-style">
</head>
<body>

<div id="control">
  <input type="submit" value="update" onclick="return update_state();">
  <input type="submit" value="clear" onclick="return clear_state();">
  <input type="text" onchange="zoom(this.value)">
</div>

<div id="msg"></div>
<div id="paper"></div>

<script src="/raphael"></script>
<script src="/jquery"></script>
<script src="/jquery-ui"></script>
<script src="/zoom"></script>
<script>
jQuery.noConflict();
jQuery(document).ready(function() {
	jQuery("#msg").draggable();
	jQuery("#msg").resizable();
	jQuery("#zoom").slider({
		max: 3, 
		min: 1, 
		step: 0.5, 
		value: 1,
		change: function(event, ui) {
			zoom(ui.value);
		},
	});
});

Raphael.fn.line = function(s, e) {
	if (s[0] == e[0] && s[1] == e[1]) {
		return this.rect(s[0], e[0], 2, 2);
	} else {
		return this.path("M" + s[0] + " " + s[1] + " " +
		      	  "L" + e[0] + " " + e[1] + " z");		
	}
}

var w = 2400;
var h = 5000;
var margin = [10, 150, 10, 10];
var server_padding = 40;
var conn_pad = 24; // padding between connections
var conn_w = 10;  // how wide the connection is
var http_w = 6;  // how wide http request and response messages are
var pix_per_sec = 200;  // pixels per second
var first;


var htracr = {
	paper: Raphael(document.getElementById("paper"), w, h).initZoom(),
	msg: document.getElementById("msg"),
	conns: {},
	urls: {},
	refs: {},
	first: undefined,
	
	draw_trace: function () {
		var self = this;
		self.paper.clear();
		var y = margin[0];
		for (server in self.conns) {
			self.paper.text(
				margin[3], 
	 			y, 
	 			server
			).attr({
				'font-size': 24,
				'text-anchor': 'start',
				'font-weight': 'bold',
				'fill': "#666",
			});
			var s = self.conns[server];
			for (connection in s) {
				y += conn_pad;
				var c = s[connection];
				self.process_conn(c, y);
			}
			y += conn_pad;
			// line between severs
//			self.paper.line([margin[3], y], [w - margin[1], y]).attr({
//				"stroke": "#ccc",
//				"stroke-width": "1",
//				"stroke-dasharray": ".",
//			});
			y += server_padding;
		};
//		self.draw_refs();
	},

	process_conn: function (conn, y) {
		var self = this;
		var conn_start = margin[3];
		var conn_end = w - margin[1];
		var packets = [];
		var http_reqs = [];
		var http_ress = [];

		if (! conn) {
			console.log("got bad conn... " + conn);
			return; // shrug
		}

		conn.forEach(function(item) {
			switch (item.what) {
				case "packet-in":
				case "packet-out":
					packets.push(item);
					break;
				case "tcp-start":
					conn_start = self.time_x(item.time);
					break;
				case "tcp-end":
					conn_end = self.time_x(item.time);
					break;
				case "http-req-start":
					http_reqs.push([self.time_x(item.time), null, item.details]);
					break;
				case "http-req-end":
					http_reqs.slice(-1)[0][1] = self.time_x(item.time);
					break;
				case "http-res-start":
					http_ress.push([self.time_x(item.time), null, item.details]);
					break;
				case "http-res-end":
					http_ress.slice(-1)[0][1] = self.time_x(item.time);
					break;
				default:
					console.log("unknown item: " + item.what);
					break;
			}
		});

	  self.draw_conn(conn_start, conn_end, y);
		packets.forEach(function(i) {
			self.draw_packet(i, y);
		});
				
		function show_hdrs(hdrs) {
				var l = [];
				for (h in hdrs) {
					var v = hdrs[h];
					l.push(h + ": " + v);
				}
				return l.join("<br>");
		}
		
		http_reqs.forEach(function(req) {
			self.draw_http_message('req', y, req[0], req[1],
				req[2].method + " " + req[2].url + " HTTP/" + req[2].http_version + 
				"<br>" + show_hdrs(req[2].headers)
			);

			var url = "http://" + req[2].headers.Host + req[2].url;
			self.urls[url] = [req[0], y];

			var ref = req[2].headers.Referer;
			if (ref) {
				(self.refs[ref] = self.refs[ref] || []).push([req[0], y]);
			}	
		});

		http_ress.forEach(function(res) {
			self.draw_http_message('res', y, res[0], res[1],
				"HTTP/" + res[2].http_version + " " + res[2].status_code + "<br>" +
				show_hdrs(res[2].headers)
			);
		});
	},

  draw_conn: function(conn_start, conn_end, y) {
		var self = this;
		self.paper.line(
			[conn_start, y], [conn_end, y]
		).attr({
			"stroke": "#ddd",
			"stroke-width": conn_w,
		});
  },

	draw_packet: function(item, y) {
		var self = this;
		var my_x = self.time_x(item.time);
		var pkt_e = self.paper.line(
			[my_x, y],
			[my_x, item.what == 'packet-in' ? y + (conn_w / 2) : y - (conn_w / 2)]
		).attr({
			"stroke-width": "1",
			"stroke": "black",
		});
		self.hover(pkt_e, self.show_packet(item.details));		
	},

	show_packet: function(details) {
		return details.data;
	},

	draw_http_message: function(msg_type, y, start, end, details) {
			var msg_e = self.paper.rect(
				start, 
				y + ( msg_type == 'req' ? -(conn_w / 2) - http_w : (conn_w / 2) ),
				self.show(end - start),
				http_w
			).attr({
				"stroke": "none",
				"fill": "red",
				"opacity": .6,
			});
			self.hover(msg_e, details);		
	},

	hover: function(e, html) {
		e.hover(function(event) {
			self.msg.innerHTML = html;
		}, function(event) {
			self.msg.innerHTML = "";
		});
	},

	draw_refs: function() {
		var self = this;
		for (ref in self.refs) {
			if (self.urls[ref]) {
				self.refs[ref].forEach(function(s) {
					self.paper.line(s, self.urls[ref]);					
				});
			}
		}
	},

	show: function(x) {
		if (x < 3) {
			return 3;
		}
		return x;
	},

	start_time: function () {
		self = this;
		if (self.first) {
			return self.first;
		}
		var f = undefined;
		for (server in self.conns) {
			for (connection in self.conns[server]) {
				var t = self.conns[server][connection][0].time;
				if (! f || (t < f)) {
					f = t;
				}
			}
		}
		self.first = f;
		console.log("start time: " + f);
		return f;
	},

	time_x: function (t) {
		var delta = t - this.start_time();
		var pix = delta * pix_per_sec / 1000;
		var x = Math.min(margin[3] + pix, w - margin[1]);
		return x;
	},
	
	clear: function () {
		this.conns = {};
		this.first = undefined;
		this.urls = {};
		this.refs = {};
		this.draw_trace();
		console.log('cleared.');
	}

}



function update_state() {
	console.log('updating...');
	var req = get_req();
	req.onreadystatechange = function () {
		if (req.readyState == 4) {
			// FIXME: proper json parse, please!
			htracr.conns = eval("(" + req.responseText + ")");
			htracr.draw_trace();
			console.log('updated.');
		}; 
	};
	req.open("GET", "/conns", true);
	req.send("");
	return false;
}

function clear_state() {
	console.log('clearing...');
	var req = get_req();
	req.onreadystatechange = function () {
		if (req.readyState == 4) {
			htracr.clear();
		}; 
	};
	req.open("POST", "/clear", true);
	req.send("");
	return false;
}

function zoom(val) {
	console.log("zooming to " + val + "...");
	htracr.paper.setZoom(val);
}

function get_req() {
	var req;
	if (window.XMLHttpRequest) {
		try {
		  req = new XMLHttpRequest();
		} catch(e) {
		  req = false;
		}
	} else if (window.ActiveXObject) {
		try {
		  req = new ActiveXObject("Microsoft.XMLHTTP");
		} catch(e) {
		  req = false;
		}
	}
	return req;
}
	

</script>

</body>
</html>