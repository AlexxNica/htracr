<html>
<head>
	<style type="text/css">
	body {
		font-family: helvetica, arial, sans-serif;
	}
	#msg {
		position: fixed;
		top: 30px;
		right: 30px;
		width: 500px;
		height: 200px;
		background-color: white;
		border: 1px dotted #999;
		opacity: 0.9;
		font-size: 0.9em;
	}
	#paper {
		margin-top: 150px;
	}
	</style>
</head>
<body>

<input type="submit" value="update" onclick="return update_state();">
<input type="submit" value="clear" onclick="return clear_state();">

<div id="msg"></div>
<div id="paper"></div>
<script src="/raphael"></script>
<script src="/jquery"></script>
<script>

$("#msg").draggable();

Raphael.fn.line = function(s, e) {
	if (s[0] == e[0] && s[1] == e[1]) {
		return this.rect(s[0], e[0], 2, 2);
	} else {
		return this.path("M" + s[0] + " " + s[1] + " " +
		      	  "L" + e[0] + " " + e[1] + " z");		
	}
}

var w = 2400;
var h = 5000;
var margin = [10, 150, 10, 10];
var server_padding = 40;
var conn_pad = 24;
var conn_w = 16;
var http_w = conn_w / 2;
var http_c = http_w / 2;
var pix_per_sec = 200;
var first;


var htracr = {
	paper: Raphael(document.getElementById("paper"), w, h),
	msg: document.getElementById("msg"),
	conns: {},
	urls: {},
	refs: {},
	first: undefined,
	
	draw_trace: function () {
		var self = this;
		self.paper.clear();
		var y = margin[0];
		for (server in self.conns) {
			self.paper.text(
				margin[3], 
	 			y, 
	 			server
			).attr({
				'font-size': 24,
				'text-anchor': 'start',
				'font-weight': 'bold',
				'fill': "#666",
			});
			var s = self.conns[server];
			for (connection in s) {
				y += conn_pad;
				var c = s[connection];
				self.draw_connection(c, y);
			}
			y += conn_pad;
			// line between severs
			self.paper.line([margin[3], y], [w - margin[1], y]).attr({
				"stroke": "#ccc",
				"stroke-width": "1",
				"stroke-dasharray": ".",
			});
			y += server_padding;
		};
		self.draw_refs();
	},

	draw_connection: function (conn, y) {
		var self = this;
		var conn_start = margin[3];
		var conn_end = w - margin[1];
		var http_reqs = [];
		var http_ress = [];

		if (! conn) {
			console.log("got bad conn... " + conn);
			return; // shrug
		}

		conn.forEach(function(item) {
			switch (item.what) {
				case "packet-in":
				case "packet-out":
					self.paper.circle(
						self.time_x(item.time), 
						item.what == 'packet-in' ? y+http_c : y-http_c, http_c
					).attr({
						'fill': item.details == "SYN" ? 'red': 'yellow', 
						"stroke": "none"
					});
					break;
				case "tcp-start":
					conn_start = self.time_x(item.time);
					break;
				case "tcp-end":
					conn_end = self.time_x(item.time);
					break;
				case "http-req-start":
					http_reqs.push([self.time_x(item.time), null, item.details]);
					break;
				case "http-req-end":
					http_reqs.slice(-1)[0][1] = self.time_x(item.time);
					break;
				case "http-res-start":
					http_ress.push([self.time_x(item.time), null, item.details]);
					break;
				case "http-res-end":
					http_ress.slice(-1)[0][1] = self.time_x(item.time);
					break;
				default:
					console.log("unknown item: " + item.what);
					break;
			}
		});
		self.paper.line(
			[conn_start, y], [conn_end, y]
		).attr({
			"stroke": "#ccc",
			"stroke-width": conn_w,
			"opacity": ".6",
		});
		
		function show_hdrs(hdrs) {
				var l = [];
				for (h in hdrs) {
					var v = hdrs[h];
					l.push(h + ": " + v);
				}
				return l.join("<br>");
		}
		
		http_reqs.forEach(function(req) {
			var my_x = req[0];
			var my_y = y - http_w;
			var req_e = self.paper.rect(
				my_x, 
				my_y,
				self.show(req[1] - req[0]),
				http_w 
			).attr({
				"stroke": "none",
				"fill": "green",
				"opacity": .6,
			});
			req_e.hover(function(event){
				var top = [req[2].method + " " + req[2].url] + " HTTP/" + req[2].http_version + "<br>";
				var hdrs = show_hdrs(req[2].headers);
				self.msg.innerHTML = top + hdrs;
			}, function(event) {
				self.msg.innerHTML = "";
			});

			var url = "http://" + req[2].headers.Host + req[2].url;
			console.log("storing url: " + url);
			self.urls[url] = [my_x, my_y];

			var ref = req[2].headers.Referer;
			if (ref) {
				(self.refs[ref] = self.refs[ref] || []).push([my_x, my_y]);
			}	
		});

		http_ress.forEach(function(res) {
			var my_x = res[0];
			var my_y = y;
			res_e = self.paper.rect(
				my_x, 
				my_y,
				self.show(res[1] - res[0]),
				http_w
			).attr({
				"stroke": "none",
				"fill": "blue",
				"opacity": .6,
			})
			res_e.hover(function(event){
				var top = ["HTTP/" + res[2].http_version + " " + res[2].status_code] + "<br>";
				var hdrs = show_hdrs(res[2].headers);
				self.msg.innerHTML = top + hdrs;
			}, function(event) {
				self.msg.innerHTML = "";
			});
		});
	},

	draw_refs: function() {
		var self = this;
		console.log('drawing refs...');
		for (ref in self.refs) {
			console.log('checking ref ' + ref);
			if (self.urls[ref]) {
				console.log('found ref!');
				self.refs[ref].forEach(function(s) {
					self.paper.line(s, self.urls[ref]);					
				});
			}
		}
	},

	show: function(x) {
		if (x < 3) {
			return 3;
		}
		return x;
	},

	start_time: function () {
		self = this;
		if (self.first) {
			return self.first;
		}
		var f = undefined;
		for (server in self.conns) {
			for (connection in self.conns[server]) {
				var t = self.conns[server][connection][0].time;
				if (! f || (t < f)) {
					f = t;
				}
			}
		}
		self.first = f;
		console.log("start time: " + f);
		return f;
	},

	time_x: function (t) {
		var delta = t - this.start_time();
		var pix = delta * pix_per_sec / 1000;
		var x = Math.min(margin[3] + pix, w - margin[1]);
		return x;
	},
	
	clear: function () {
		this.conns = {};
		this.first = undefined;
		this.urls = {};
		this.refs = {};
		this.draw_trace();
		console.log('cleared.');
	}

}



function update_state() {
	console.log('updating...');
	var req = get_req();
	req.onreadystatechange = function () {
		if (req.readyState == 4) {
			// FIXME: proper json parse, please!
			htracr.conns = eval("(" + req.responseText + ")");
			htracr.draw_trace();
			console.log('updated.');
		}; 
	};
	req.open("GET", "/state", true);
	req.send("");
	return false;
}

function clear_state() {
	console.log('clearing...');
	var req = get_req();
	req.onreadystatechange = function () {
		if (req.readyState == 4) {
			htracr.clear();
		}; 
	};
	req.open("POST", "/clear", true);
	req.send("");
	return false;
}

function get_req() {
	var req;
	if (window.XMLHttpRequest) {
		try {
		  req = new XMLHttpRequest();
		} catch(e) {
		  req = false;
		}
	} else if (window.ActiveXObject) {
		try {
		  req = new ActiveXObject("Microsoft.XMLHTTP");
		} catch(e) {
		  req = false;
		}
	}
	return req;
}
	

</script>

</body>
</html>